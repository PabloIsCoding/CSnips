{
  "Growable Stack": {
    "prefix": ["growablestack"],
    "body": [
        "#include <assert.h>",
        "#include <stdbool.h>",
        "#include <stddef.h>",
        "#include <stdlib.h>",
        "#include <stdint.h>",
        "",
        "#define ${3/(.*)/${1:/upcase}/}_CHUNK_SIZE 100",
        "",
        "typedef enum  {",
        "    ${1/(.*)/${1:/upcase}/}_OK = 0,",
        "    ${1/(.*)/${1:/upcase}/}_OOM,",
        "    ${1/(.*)/${1:/upcase}/}_OVERFLOW,",
        "} ${1:StackResult};",
        "",
        "typedef struct ${3:Stack} {",
        "    ${4:int} *data;",
        "    size_t count;",
        "    size_t capacity;",
        "} ${3:Stack};",
        "",
        "${1} ${3:Stack}_init(${3:Stack} *s, size_t capacity){",
        "    assert(s != NULL && capacity > 0);",
        "    s->data = NULL; s->count = 0; s->capacity = 0;",
        "    if(capacity > SIZE_MAX / sizeof(*s->data)) return ${1/(.*)/${1:/upcase}/}_OVERFLOW;",
        "    s->data = malloc(capacity * sizeof(*s->data));",
        "    if (!s->data) return ${1/(.*)/${1:/upcase}/}_OOM;",
        "    s->capacity = capacity;",
        "    return ${1/(.*)/${1:/upcase}/}_OK;",
        "}",
        "",
        "bool ${3:Stack}_is_full(const ${3:Stack} *s){",
        "    assert(s != NULL);",
        "    return s->capacity <= s->count;",
        "}",
        "",
        "void ${3:Stack}_push(${3:Stack} *s,${4} new_elem){ // Unchecked version, faster, won't allocate",
        "    assert(s != NULL);",
        "    assert(!${3:Stack}_is_full(s));",
        "    s->data[s->count++] = new_elem;",
        "}",
        "",
        "${1} ${3:Stack}_push_maybe_grow(${3:Stack} *s,${4} new_elem){ // Will allocate as needed",
        "    assert(s != NULL);",
        "    if (${3:Stack}_is_full(s)){",
        "        if(s->capacity > SIZE_MAX - (size_t)${3/(.*)/${1:/upcase}/}_CHUNK_SIZE) return ${1/(.*)/${1:/upcase}/}_OVERFLOW;",
        "",
        "        size_t new_count = s->capacity + (size_t)${3/(.*)/${1:/upcase}/}_CHUNK_SIZE;",
        "        if(new_count > SIZE_MAX / sizeof(*s->data)) return ${1/(.*)/${1:/upcase}/}_OVERFLOW;",
        "",
        "       ${4} *p = realloc(s->data, new_count * sizeof(*s->data));",
        "        if (!p) return ${1/(.*)/${1:/upcase}/}_OOM;",
        "",
        "        s->data = p;",
        "        s->capacity = new_count;",
        "    }",
        "",
        "    ${3:Stack}_push(s, new_elem);",
        "    return ${1/(.*)/${1:/upcase}/}_OK;",
        "}",
        "",
        "${4} ${3:Stack}_pop(${3:Stack} *s){",
        "    assert(s != NULL);",
        "    assert(s->count > 0);",
        "    return s->data[--s->count];",
        "}",
        "",
        "void ${3:Stack}_free(${3:Stack} *s){",
        "    if(!s) return;",
        "    free(s->data);",
        "    s->capacity = 0;",
        "    s->count = 0;",
        "    s->data = NULL; // Somewhat helpful to catch dangling pointers",
        "}",
        "",
    ],
    "description": "A stack of arbitrary type. When pushing elements to it, it checks whether it needs to allocate more capacity automatically"
  }
}
